{"./":{"url":"./","title":"Home","keywords":"","body":"Home 这个人很懒，什么都没有留下 "},"C++/":{"url":"C++/","title":"C++","keywords":"","body":"C++ "},"C++/RAII.html":{"url":"C++/RAII.html","title":"RAII","keywords":"","body":"资源申请即初始化（Resource Acquisition Is Initialization，RAII），是 C++ 的一种 管理资源、避免泄漏 的方法，其做法是： 使用一个对象，在其构造时获取对应的资源； 在对象生命期内控制对资源的访问，使之始终保持有效； 最后在对象析构的时候，释放构造时获取的资源； 因此 RAII 也可以说是一种利用 对象生命周期 来控制程序资源的技术，资源的有效期与持有资源的对象的生命期严格绑定。 系统的资源不具有自动释放的功能，但由于 C++ 中的类具有自动调用析构函数的功能，所以如果把资源用类进行封装起来，对资源操作都封装在类的内部，在析构函数中进行释放资源，当定义的局部变量的生命结束时，它的析构函数就会自动的被调用，其生命周期是由操作系统来管理，无需人工介入。 以 lock_guard 为例，只需要加锁操作资源，而不需要手动解锁，锁自动释放： std::mutex m; void fn() { std::lock_guard guard(m); do_something(); // 执行完成后，lock_guard 会被析构，从而 mutex 也会被释放 } lock_guard 的源码如下： /** @brief A simple scoped lock type. * * A lock_guard controls mutex ownership within a scope, releasing * ownership in the destructor. */ template class lock_guard { public: typedef _Mutex mutex_type; explicit lock_guard(mutex_type& __m) : _M_device(__m) { _M_device.lock(); } lock_guard(mutex_type& __m, adopt_lock_t) noexcept : _M_device(__m) { } // calling thread owns mutex ~lock_guard() { _M_device.unlock(); } lock_guard(const lock_guard&) = delete; lock_guard& operator=(const lock_guard&) = delete; private: mutex_type& _M_device; }; lock_guard 构造时，会初始化内部字段执行加锁操作；析构时，会指向解锁操作，所以借助这个类，可以不需要关注解锁的操作。 "},"C++/value-categories.html":{"url":"C++/value-categories.html","title":"值类别","keywords":"","body":"1 简介 C++ 程序由一系列的 表达式（expressions）构成，表达式是 运算符、操作符 和 操作数 的序列，举例如下： 算数表达式，如 2 + 3，x * (y + z)，a / b 等； 关系表达式，如 x == y，a ，c > d 等； 逻辑表达式，如 x && y，a || b，!c 等； 条件表达式，如 x > 0 ? \"positive\" : \"negative\"，a == b ? x++ : y-- 等； 赋值表达式，如 x = 5，y += 10，z *= 2 等； 函数调用表达式，如 sum(a, b) 等； 每个表达式都有两个独立的属性： 类型（type），每个表达式都有一个确定的静态类型，这是由操作数和操作符的类型以及表达式的结构决定的，在编译时已知，例如，整数相加的表达式的类型通常是整数，逻辑表达式的类型通常是布尔值； 值类别（value category），描述了表达式生成的值的性质，每个表达式正好属于三个基础值类别之一：prvalue、xvalue 和 lvalue，另外还有两个混合值类别分别为 gvalue 和 rvalue，其之间的关系如下图所示： 2 lvalue 左值 以下表达式为 lvalue 表达式： 变量、函数、模板参数对象（从C++20开始）或成员变量的名称，如 std::cin 或者 std::endl，即使变量的类型是右值引用，由其名称组成的表达式也是左值； 返回左值引用的函数调用或重载运算符表达式，其，如 std::getline(std::cin, str) 或者 str1 = str2； 赋值和复合赋值表达式，如 a=b，a+=b； 前置自增或自减，如 ++a； 解引用，如 *p； 下标表达式，如 a[n]，其中 a 是一个左值队列； 对象获取成员，如 a.m，其中 m 不为枚举成员且不为非静态成员函数，并且 a 为 rvalue 时 m 不为非静态成员变量； 指针获取成员，如 p->m，其中 m 不为枚举成员且不为非静态成员函数； 对象获取指针成员，如 a.*mp，其中 a 是左值且 mp 是指向成员变量的指针; 指针获取指针成员，如 p->*mp，其中 mp 是指向成员变量的指针； 逗号表达式，如 a, b，其中 b 是左值； 三目运算，如 a ? b : c，其中 b 和 c 为 lvalue； string 字面值，如 \"Hello, world!\"； 转换为左值引用类型的表达式，如 static_cast(x)； 函数调用或重载运算符表达式，其返回类型为返回右值引用的函数； 转换为返回右值引用的函数类型的表达式，如 static_cast(x)； 属性： 包括 glvalue 属性； 可以进行取址，如 &++i[1]，&std::endl； 可作为赋值和复合赋值运算符的左操作数； 左值可被左值引用进行绑定； 3 prvalue 纯右值 以下表达式为 prvalue 表达式： 字面量（除 string 字面量以外），如 42； 函数调用或重载运算符表达式，其返回类型为非引用类型，如 str.substr(1, 2)； 后置自增或自减，如 a++； 算术表达式，如 a + b; 逻辑表达式，如 a && b； 比较表达式，如 a ； 取址表达式，如 &a； 对象获取成员，如 a.m，其中 m 为枚举成员或者为非静态成员函数; 指针获取成员，如 p->m，其中 m 为枚举成员或者为非静态成员函数; 对象获取指针成员，如 a.*mp，其中 mp 为指向成员函数的指针； 指针获取指针成员，如 p->*mp，其中 mp 是指向成员函数的指针； 逗号表达式，如 a, b，其中 b 是右值； 三目运算，如 a ? b : c，其中 b 和 c 为 prvalue； 转换为非引用类型的表达式，如 static_cast(x)； this 指针； 枚举变量； 非类型模板参数，除非其类型是类或（自C++20以来）左值引用类型； lambda 表达式，如 [](int x){ return x * x; }； require 表达式（C++20）； 特化的 concept（C++20）； 属性： 包括 rvalue 的属性； 没有多态的能力； 不是类且不是数组的 prvalue 不能是 cv 限定的，除非它的实现是为了绑定到一个 cv 限定类型的引用上； 必须有完整的类型； 不能具有抽象类类型或其数组； 4 xvalue 将亡值 以下表达式为 xvalue 表达式： 函数调用或重载运算符表达式，其返回右值引用对象，如 std::move(x)； 下标表达式，如 a[n]，其中 a 是一个右值队列； 对象获取成员，如 a.m，其中 a 为 rvalue 且 m 为非引用类型的非静态成员变量； 对象获取指针成员，如 a.*mp，其中 a 是右值且 mp 是指向成员变量的指针; 三目运算，如 a ? b : c，其中 b 和 c 为 xvalue； 转换为右值引用类型的表达式，如 static_cast(x)； 临时对象； 属性： 包括 rvalue 的属性； 包括 gvalue 的属性； 5 gvalue 广义左值 一个 gvalue 表达式要么是 lvalue 表达式，要么是 xvalue 表达式。 属性： gvalue 可以通过左值转换成为右值、数组转换为指针、函数转换成指针的形式，隐式转换成 prvalue； gvalue 可能是多态的； gvalue 可以具有不完整的类型； 6 rvalue 右值 一个 rvalue 表达式要么是 prvalue 表达式，要么是 xvalue 表达式。 属性： rvalue 表达式不能被取址； rvalue 不能为赋值运算符的左操作数； rvalue 可以初始化 const lvalue 引用，在这种情况下，右值标识的对象的生存期被延长，直到引用的范围结束； rvalue 可初始化 rvalue 引用，在这种情况下，右值标识的对象的生存期被延长，直到引用的范围结束； 当用作函数参数时，有两个重载可用，一个使用右值引用，一个使用 const 左值引用，rvalue 将被绑定到右值应用的重载中； 参考 https://en.cppreference.com/w/cpp/language/value_category https://blog.csdn.net/xhtchina/article/details/120619910 "},"C++/rvalue-reference.html":{"url":"C++/rvalue-reference.html","title":"右值引用","keywords":"","body":"0 关于值类别 值类别（value category） 的概念，即平时所说的 左值 和 右值，C++ 的表达式要么是左值，要么是右值。 当对象是左值时，用的是对象的身份（内存中的位置），例如普通变量； 当对象是右值时，用的是对象的值（内容），例如字面常量、表达式求值过程中创建的临时对象； 判断一个值是左值还是右值，最有效的办法之一就是看 能否对这个值进行取址操作，如果可以，则该值为左值，否则为右值；另外，也可以通过名称来判断，有名称的变量为左值，没有名称的变量为右值。 值类别更详细的说明可参考：https://edwarddong1993.github.io/C++/value-categories.html 1 左值引用 左值引用可以绑定左值，但不能直接绑定右值： int a = 42; int &r1 = a; // ok int &r2 = 42; // error const 的左值引用可以绑定右值： const int &r2 = 42; // ok 2 右值引用 右值引用可以绑定右值，但不能绑定左值： int a = 42; int &&rr1 = a; // error int &&rr2 = 42; // ok 一个右值引用绑定临时对象的例子如下： class test { public: test() = default; test(const test &other) { std::cout 如果想要使右值引用绑定某个左值，可以使用 std::move 将左值强制变为右值引用（std::move 的原理在下文进行介绍）： int a = 42; int &&rr = std::move(a); // ok 由于右值绑定的对象都是临时的，在使用右值引用的时候，所引用的对象状态如下： 所引用的对象将要被销毁； 该对象没有其他用户； 所以，使用右值引用的代码可以接管所引用的对象的资源。 [info] For info 右值引用指向将要被销毁的对象，一次，可以从绑定到右值引用的对象中窃取资源。 由此，右值引用引申出了如下两个功能： 移动语义（Move Semantics） 完美转发（Perfect Forward） 3 引用折叠规则 在介绍移动语义和完美转发之前，需要先介绍一下 引用折叠。 规则 1：将一个左值传递给函数的右值引用参数，且此右值引用指向模板类型参数（如 T&&），编译器推断模板类型参数为实参的左值引用类型： template void f(T&&); int i = 42; f(i); 当调用 f(i) 时，编译器推断 T 的类型为 int& 而非 int。 规则 2：T 被推断为 int& 意味着函数 f 的参数应该是 int& 的右值引用，但是不能直接定义一个引用的引用（因为引用并不是对象），所以这里给出规则2：如果间接的创建了引用的引用，引用会折叠成一个普通的引用： X& &，X& &&，X&& & 将折叠成左值引用 X&; X&& && 将折叠成为右值引用 X&&; 上述两个规则导致了两个重要结果： 如果一个函数参数是一个指向模板参数的右值引用（T&&），则它可以被绑定到一个左值； 如果实参是一个左值，则推断出的模板实参将会是一个左值引用，且函数参数将被实例化为一个普通的左值引用参数（T&）； [info] For info 引用折叠只能用于间接创建的引用的引用，如 类型别名 或者 模板参数。 4 移动语义 在这里继续看一下 std::move 的实现，事实上 std::move 唯一的功能是就是把输入的参数强制转化为右值引用，具体实现如下： /** * @brief Convert a value to an rvalue. * @param __t A thing of arbitrary type. * @return The parameter cast to an rvalue-reference to allow moving it. */ template constexpr typename std::remove_reference::type&& move(_Tp&& __t) noexcept { return static_cast::type&&>(__t); } 如果输入的参数是左值，经过引用折叠后会变成左值引用，而 std::remove_reference::type&&> 操作会将其类型变成一个右值引用并返回。 移动语义还可以为类定义移动构造函数（move constructor）和移动赋值（move assignment）运算符： X(X&&); X& operator=(X&&); [info] For info 上述中入参均为右值引用，表示该入参中的资源可以被“窃取”走，实现资源的移动，取代复制操作，避免了资源消耗，而由于输入参数中包含的值可能已经被移动走了，后续不应当再使用该变量。 5 完美转发 某些函数需要将实参连同类型不变的转发给其它函数，需要保持被转发的实参的所有性质，包括是否为 const 以及左值还是右值。 step 1 template void flip(F f, T1 t1, T2 t2) { f(t2, t1); } 如果函数 f 的参数为引用，则会出现问题： void f(int v1, int & v2) { //... } 如果通过 flip 调用，就不会改变实参的值。 step 2 template void flip(F f, T1 &&t1, T2 &&t2) { f(t2, t1); } 通过引用折叠，可以保持实参的左值右值属性，但不能传递右值引用参数： void f(int &&i, int &j) { //... } 例如调用 flip(f, i, 42) 时，在 flip 函数内部 t2 为变量（左值表达式），不能从左值实例化为右值。 step 3 使用 std::forward，能保持原始参数类型以及相应的属性，其源码如下： /** * @brief Forward an lvalue. * @return The parameter cast to the specified type. * * This function is used to implement \"perfect forwarding\". */ template constexpr _Tp&& forward(typename std::remove_reference::type& __t) noexcept { return static_cast(__t); } /** * @brief Forward an rvalue. * @return The parameter cast to the specified type. * * This function is used to implement \"perfect forwarding\". */ template constexpr _Tp&& forward(typename std::remove_reference::type&& __t) noexcept { static_assert(!std::is_lvalue_reference::value, \"template argument\" \" substituting _Tp is an lvalue reference type\"); return static_cast(__t); } std::forward 提供左值和右值两个接口，分别返回其相应的折叠引用，保证转发的性质不变，另外，std::forward 必须通过显示模板实参来调用，最终转发函数可修改如下： template void flip(F f, T1 &&t1, T2 &&t2) { f(std::forwardt2, std::forward(t1)); } 参考 https://blog.csdn.net/xhtchina/article/details/120619910 https://zhuanlan.zhihu.com/p/335994370 《C++ primer》 "}}